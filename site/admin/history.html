<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History - Reverie House</title>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/pages/database.css">
    
    <!-- Favicon and Icons -->
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
    
    <!-- Core utilities -->
    <script src="/js/core/world-config-cache.js"></script>
    <script src="/js/core/color-manager.js"></script>
    
    <!-- Header and drawer widgets -->
    <script src="/js/widgets/header.js" defer></script>
    <script type="module" src="/js/widgets/oauth-manager.js"></script>
    <script src="/js/widgets/drawer.js" defer></script>
    <script src="/js/widgets/konami.js" defer></script>
    
    <style>
        .modal-overlay {
            display: none !important;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex !important;
        }
        
        .canon-modal-content {
            background: white;
            border-radius: 0;
            border: 1.5px solid var(--border);
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            z-index: 100000;
        }
        
        .modal-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1.5px solid var(--border);
        }
        
        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-dark);
            margin: 0;
            font-family: monospace;
        }
        
        .form-group {
            margin-bottom: 0.9rem;
        }
        
        .form-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.3rem;
            font-family: monospace;
        }
        
        .form-input {
            width: 100%;
            padding: 6px 8px;
            border: 1.5px solid var(--border);
            border-radius: 0;
            font-family: monospace;
            font-size: 0.8rem;
            background: var(--bg-white);
            color: var(--text);
            box-sizing: border-box;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-light);
        }
        
        .form-help {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.2rem;
            font-family: monospace;
            font-style: italic;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .input-with-button {
            display: flex;
            gap: 0.5rem;
        }
        
        .input-with-button .form-input {
            flex: 1;
        }
        
        .input-with-button .btn-small {
            padding: 6px 10px;
            font-size: 0.75rem;
            white-space: nowrap;
            border: 1.5px solid var(--border);
            background: var(--bg-white);
            color: var(--text);
            font-family: monospace;
            cursor: pointer;
        }
        
        .input-with-button .btn-small:hover {
            background: var(--bg-light);
            border-color: var(--primary);
        }
        
        .autocomplete-container {
            position: relative;
        }
        
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1.5px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-suggestions.active {
            display: block;
        }
        
        .autocomplete-item {
            padding: 6px 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .autocomplete-item:hover {
            background: var(--bg-light);
        }
        
        .autocomplete-item .item-name {
            font-weight: 600;
            color: var(--text);
        }
        
        .autocomplete-item .item-handle {
            color: var(--text-dim);
            font-size: 0.7rem;
        }
        
        .modal-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.25rem;
            padding-top: 0.75rem;
            border-top: 1.5px solid var(--border);
        }
        
        .status-msg {
            padding: 0.75rem 1rem;
            border-radius: 0;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            font-family: monospace;
        }
        
        .status-msg.success {
            background: #d1fae5;
            color: #065f46;
            border: 1.5px solid #10b981;
        }
        
        .status-msg.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1.5px solid #ef4444;
        }
        
        .row-entry .cell.edit-cell {
            flex: 0 0 140px;
            max-width: 140px;
            min-width: 140px;
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
        }
        
        .confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            align-items: center;
            justify-content: center;
        }
        
        .confirm-modal.active {
            display: flex;
        }
        
        .confirm-modal-content {
            background: white;
            border: 1.5px solid var(--border);
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .confirm-modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-dark);
            margin: 0 0 1rem 0;
            font-family: monospace;
        }
        
        .confirm-modal-message {
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text);
            margin-bottom: 1.5rem;
        }
        
        .confirm-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        
        .btn-delete {
            background: #dc2626;
            color: white;
            border: 1.5px solid #b91c1c;
        }
        
        .btn-delete:hover {
            background: #b91c1c;
        }
    </style>
</head>
<body>
    <div class="page-header">
        <div class="search-box">
            <input type="text" id="search" placeholder="Search canon...">
            <span class="search-icon">üîç</span>
        </div>
        <button class="btn btn-primary" onclick="showAddModal()">+ Add Record</button>
        <button class="btn btn-secondary" onclick="loadCanonEntries()">üîÑ Refresh</button>
    </div>
    
    <div class="table-header">
        <div class="table-title">‚åõ Canon History</div>
        <div class="table-count" id="recordCount">0 rows</div>
    </div>

    <div id="rows-container">
        <!-- Rows will be displayed here -->
    </div>
    
    <!-- Add/Edit Modal -->
    <div class="modal-overlay" id="canonModal">
        <div class="canon-modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Add Canon Entry</h2>
            </div>
            
            <div id="statusMsg"></div>
            
            <form id="canonForm" onsubmit="handleSubmit(event)">
                <input type="hidden" id="entryId" value="">
                
                <div class="form-group autocomplete-container">
                    <label class="form-label">DID / Handle / Name *</label>
                    <input type="text" class="form-input" id="did" required autocomplete="off">
                    <div class="autocomplete-suggestions" id="didSuggestions"></div>
                    <div class="form-help">Search by DID, handle, or name</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Event *</label>
                    <input type="text" class="form-input" id="event" required>
                    <div class="form-help">Description of the canon event</div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Type *</label>
                        <select class="form-input" id="typeSelect" onchange="handleTypeChange()">
                            <option value="">-- Select Type --</option>
                        </select>
                        <input type="text" class="form-input" id="typeCustom" placeholder="Enter custom type..." style="display: none; margin-top: 0.5rem;">
                        <div class="form-help">Event type</div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Key *</label>
                        <select class="form-input" id="keySelect" onchange="handleKeyChange()">
                            <option value="">-- Select Key --</option>
                        </select>
                        <input type="text" class="form-input" id="keyCustom" placeholder="Enter custom key..." style="display: none; margin-top: 0.5rem;" required>
                        <div class="form-help">Unique key</div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Link (URI or URL)</label>
                    <input type="text" class="form-input" id="link" placeholder="at://... or https://...">
                    <div class="form-help">AT Protocol URI or HTTP URL - auto-detected</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Epoch</label>
                    <div class="input-with-button">
                        <input type="number" class="form-input" id="epoch" value="">
                        <button type="button" class="btn-small" onclick="setEpochFromLink()">Post Time</button>
                        <button type="button" class="btn-small" onclick="setEpochNow()">Now Time</button>
                    </div>
                    <div class="form-help">Unix timestamp</div>
                </div>
                
                <div class="modal-actions">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div class="confirm-modal" id="deleteModal">
        <div class="confirm-modal-content">
            <h2 class="confirm-modal-title">Delete Canon Entry?</h2>
            <div class="confirm-modal-message" id="deleteMessage">
                Are you sure you want to delete this canon entry? This action cannot be undone.
            </div>
            <div class="confirm-modal-actions">
                <button type="button" class="btn btn-delete" onclick="confirmDelete()">Delete</button>
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global functions (must be accessible from onclick handlers)
        
        function showAddModal() {
            document.getElementById('modalTitle').textContent = 'Add Canon Entry';
            document.getElementById('canonForm').reset();
            document.getElementById('entryId').value = '';
            document.getElementById('statusMsg').innerHTML = '';
            document.getElementById('canonModal').classList.add('active');
        }
        
        function closeModal() {
            document.getElementById('canonModal').classList.remove('active');
            document.getElementById('didSuggestions').classList.remove('active');
        }
        
        // Delete modal functions
        let deleteEntryId = null;
        
        function showDeleteModal(id) {
            const entry = canonData.find(e => e.id === id);
            if (!entry) return;
            
            deleteEntryId = id;
            const name = entry.name || 'Unknown';
            const event = entry.event || 'unknown event';
            
            document.getElementById('deleteMessage').innerHTML = `
                Are you sure you want to delete this canon entry?<br><br>
                <strong>${escapeHtml(name)}</strong> <em>${escapeHtml(event)}</em><br><br>
                This action cannot be undone.
            `;
            document.getElementById('deleteModal').classList.add('active');
        }
        
        function closeDeleteModal() {
            document.getElementById('deleteModal').classList.remove('active');
            deleteEntryId = null;
        }
        
        async function confirmDelete() {
            if (!deleteEntryId) return;
            
            try {
                const response = await fetch(`/api/admin/canon/${deleteEntryId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${adminToken}`
                    }
                });
                
                if (response.ok) {
                    closeDeleteModal();
                    await loadCanonEntries();
                    showToast('Entry deleted successfully', 'success');
                } else {
                    const error = await response.json().catch(() => ({}));
                    showToast(error.error || 'Failed to delete entry', 'error');
                }
            } catch (error) {
                console.error('Delete error:', error);
                showToast('Failed to delete entry: ' + error.message, 'error');
            }
        }
        
        function handleTypeChange() {
            const select = document.getElementById('typeSelect');
            const customInput = document.getElementById('typeCustom');
            
            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.required = true;
            } else {
                customInput.style.display = 'none';
                customInput.required = false;
            }
        }
        
        function handleKeyChange() {
            const select = document.getElementById('keySelect');
            const customInput = document.getElementById('keyCustom');
            
            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.required = true;
            } else {
                customInput.style.display = 'none';
                customInput.required = false;
            }
        }
        
        function setEpochNow() {
            document.getElementById('epoch').value = Math.floor(Date.now() / 1000);
        }
        
        async function setEpochFromLink() {
            const link = document.getElementById('link').value;
            
            if (!link) {
                alert('Please enter a link first');
                return;
            }
            
            let atUri = '';
            let did = '';
            
            if (link.startsWith('at://')) {
                atUri = link;
                const match = atUri.match(/^at:\/\/(did:[^\/]+)/);
                if (match) {
                    did = match[1];
                }
            } else if (link.includes('bsky.app/profile/') || link.includes('/profile/')) {
                const match = link.match(/profile\/([^\/]+)\/post\/([^\/\?]+)/);
                if (match) {
                    const handle = match[1];
                    const rkey = match[2];
                    
                    try {
                        // First resolve handle to DID using Bluesky's API
                        const resolveResp = await fetch(`https://bsky.social/xrpc/com.atproto.identity.resolveHandle?handle=${handle}`);
                        if (!resolveResp.ok) {
                            throw new Error('Handle not found');
                        }
                        const resolveData = await resolveResp.json();
                        did = resolveData.did;
                        atUri = `at://${did}/app.bsky.feed.post/${rkey}`;
                    } catch (e) {
                        console.error('Failed to resolve handle via Bluesky:', e);
                        alert('Could not resolve handle: ' + handle);
                        return;
                    }
                } else {
                    alert('Invalid post URL format');
                    return;
                }
            } else {
                alert('Link must be an AT URI (at://...) or post URL');
                return;
            }
            
            let pdsEndpoint = '';
            try {
                const didDocResp = await fetch(`https://plc.directory/${did}`);
                const didDoc = await didDocResp.json();
                
                const pdsService = didDoc.service?.find(s => s.id === '#atproto_pds');
                if (pdsService) {
                    pdsEndpoint = pdsService.serviceEndpoint;
                } else {
                    throw new Error('No PDS endpoint found in DID document');
                }
            } catch (e) {
                console.error('Failed to get DID document:', e);
                alert('Could not find PDS for this user');
                return;
            }
            
            try {
                const parts = atUri.replace('at://', '').split('/');
                const collection = parts[1];
                const rkey = parts[2];
                
                const url = `${pdsEndpoint}/xrpc/com.atproto.repo.getRecord?repo=${did}&collection=${collection}&rkey=${rkey}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.value && data.value.createdAt) {
                    const createdAt = new Date(data.value.createdAt);
                    const epoch = Math.floor(createdAt.getTime() / 1000);
                    document.getElementById('epoch').value = epoch;
                } else {
                    alert('Could not find createdAt timestamp in record');
                }
            } catch (e) {
                console.error('Failed to fetch record:', e);
                alert('Failed to fetch post data: ' + e.message);
            }
        }
        
        function closeModal() {
            document.getElementById('canonModal').classList.remove('active');
        }
        
        function editEntry(id) {
            const entry = canonData.find(e => e.id === id);
            if (!entry) return;
            
            document.getElementById('modalTitle').textContent = 'Edit Canon Entry';
            document.getElementById('entryId').value = entry.id;
            document.getElementById('did').value = entry.did;
            document.getElementById('event').value = entry.event;
            
            // Set type dropdown
            const typeSelect = document.getElementById('typeSelect');
            const typeCustom = document.getElementById('typeCustom');
            const typeOption = Array.from(typeSelect.options).find(opt => opt.value === entry.type);
            
            if (typeOption) {
                typeSelect.value = entry.type;
                typeCustom.style.display = 'none';
                typeCustom.required = false;
            } else {
                typeSelect.value = '__custom__';
                typeCustom.value = entry.type;
                typeCustom.style.display = 'block';
                typeCustom.required = true;
            }
            
            // Set key dropdown
            const keySelect = document.getElementById('keySelect');
            const keyCustom = document.getElementById('keyCustom');
            const keyOption = Array.from(keySelect.options).find(opt => opt.value === entry.key);
            
            if (keyOption) {
                keySelect.value = entry.key;
                keyCustom.style.display = 'none';
                keyCustom.required = false;
            } else {
                keySelect.value = '__custom__';
                keyCustom.value = entry.key;
                keyCustom.style.display = 'block';
                keyCustom.required = true;
            }
            
            // Set link field (prefer URI over URL)
            document.getElementById('link').value = entry.uri || entry.url || '';
            document.getElementById('epoch').value = entry.epoch || '';
            document.getElementById('statusMsg').innerHTML = '';
            document.getElementById('canonModal').classList.add('active');
        }
        
        // Authentication & Authorization
        
        const adminToken = localStorage.getItem('admin_token');
        
        if (!adminToken) {
            window.location.href = '/admin/login.html';
        } else {
            fetch('/api/admin/verify', {
                headers: {
                    'Authorization': `Bearer ${adminToken}`
                }
            }).then(response => {
                if (!response.ok) {
                    localStorage.removeItem('admin_token');
                    window.location.href = '/admin/login.html';
                } else {
                    return response.json();
                }
            }).then(data => {
                if (data) {
                    const adminSession = {
                        did: data.did,
                        handle: data.handle,
                        displayName: data.handle,
                        isAdmin: true
                    };
                    
                    sessionStorage.setItem('admin_session', JSON.stringify(adminSession));
                    
                    window.dispatchEvent(new CustomEvent('oauth:login', {
                        detail: { session: adminSession }
                    }));
                    
                    loadCanonEntries();
                }
            }).catch(error => {
                console.error('Auth check failed:', error);
                localStorage.removeItem('admin_token');
                window.location.href = '/admin/login.html';
            });
        }
        
        // Canon Management
        
        let canonData = [];
        let filteredData = [];
        let dreamersCache = [];
        
        async function loadCanonEntries() {
            try {
                const response = await fetch('/api/canon');
                canonData = await response.json();
                filteredData = canonData;
                renderTable(filteredData);
                updateCount();
                populateDropdowns();
            } catch (error) {
                console.error('Failed to load canon entries:', error);
                document.getElementById('rows-container').innerHTML = 
                    '<div style="text-align: center; padding: 3rem; color: #ef4444; font-family: monospace;">Failed to load canon history</div>';
            }
        }
        
        function populateDropdowns() {
            // Get unique types and keys
            const types = [...new Set(canonData.map(e => e.type).filter(Boolean))];
            const keys = [...new Set(canonData.map(e => e.key).filter(Boolean))];
            
            const typeSelect = document.getElementById('typeSelect');
            const keySelect = document.getElementById('keySelect');
            
            // Clear and populate type dropdown
            typeSelect.innerHTML = '<option value="">-- Select Type --</option>';
            types.forEach(type => {
                typeSelect.innerHTML += `<option value="${escapeHtml(type)}">${escapeHtml(type)}</option>`;
            });
            typeSelect.innerHTML += '<option value="__custom__">+ Enter Custom Type</option>';
            
            keySelect.innerHTML = '<option value="">-- Select Key --</option>';
            keys.forEach(key => {
                keySelect.innerHTML += `<option value="${escapeHtml(key)}">${escapeHtml(key)}</option>`;
            });
            keySelect.innerHTML += '<option value="__custom__">+ Enter Custom Key</option>';
        }
        
        // DID autocomplete
        let didAutocompleteTimeout;
        document.addEventListener('DOMContentLoaded', () => {
            const didInput = document.getElementById('did');
            const suggestions = document.getElementById('didSuggestions');
            
            didInput.addEventListener('input', (e) => {
                clearTimeout(didAutocompleteTimeout);
                const query = e.target.value.trim();
                
                if (query.length < 2) {
                    suggestions.classList.remove('active');
                    return;
                }
                
                didAutocompleteTimeout = setTimeout(async () => {
                    await searchDreamers(query);
                }, 300);
            });
            
            didInput.addEventListener('blur', () => {
                setTimeout(() => suggestions.classList.remove('active'), 200);
            });
        });
        
        async function searchDreamers(query) {
            try {
                const lowerQuery = query.toLowerCase();
                const matches = canonData
                    .filter(entry => {
                        const did = entry.did?.toLowerCase() || '';
                        const name = entry.name?.toLowerCase() || '';
                        const handle = entry.handle?.toLowerCase() || '';
                        return did.includes(lowerQuery) || name.includes(lowerQuery) || handle.includes(lowerQuery);
                    })
                    .map(entry => ({
                        did: entry.did,
                        name: entry.name || 'Unknown',
                        handle: entry.handle || ''
                    }));
                
                const uniqueMatches = [];
                const seenDids = new Set();
                for (const match of matches) {
                    if (!seenDids.has(match.did)) {
                        seenDids.add(match.did);
                        uniqueMatches.push(match);
                    }
                }
                
                const suggestions = document.getElementById('didSuggestions');
                suggestions.innerHTML = '';
                
                if (uniqueMatches.length === 0) {
                    suggestions.classList.remove('active');
                    return;
                }
                
                uniqueMatches.slice(0, 10).forEach(dreamer => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `
                        <div class="item-name">${escapeHtml(dreamer.name)}</div>
                        <div class="item-handle">${dreamer.handle ? '@' + escapeHtml(dreamer.handle) + ' ‚Ä¢ ' : ''}${escapeHtml(dreamer.did)}</div>
                    `;
                    item.onclick = () => selectDreamer(dreamer);
                    suggestions.appendChild(item);
                });
                
                suggestions.classList.add('active');
            } catch (error) {
                console.error('Failed to search dreamers:', error);
            }
        }
        
        function selectDreamer(dreamer) {
            document.getElementById('did').value = dreamer.did;
            document.getElementById('didSuggestions').classList.remove('active');
        }
        
        function updateCount() {
            document.getElementById('recordCount').textContent = `${filteredData.length} records`;
        }
        
        function renderTable(data) {
            const container = document.getElementById('rows-container');
            container.innerHTML = '';
            
            if (data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 3rem; color: var(--text-dim); font-family: monospace;">No canon entries found</div>';
                return;
            }
            
            container.innerHTML = `
                <div class="row-header">
                    <div class="cell avatar"></div>
                    <div class="cell canon">Canon Event</div>
                    <div class="cell type">Type</div>
                    <div class="cell key">Key</div>
                    <div class="cell epoch">Date</div>
                    <div class="cell edit-cell">Actions</div>
                </div>
            `;
            
            data.forEach(entry => {
                const row = document.createElement('div');
                row.className = 'row-entry';
                
                const epochDisplay = entry.epoch ? formatEpoch(entry.epoch) : 'N/A';
                
                const avatarImg = entry.avatar ? 
                    `<img src="${entry.avatar}" class="avatar-img" alt="avatar" onerror="this.src='/assets/icon_face.png'">` :
                    '<img src="/assets/icon_face.png" class="avatar-img" alt="avatar">';
                
                const name = entry.name || 'unknown';
                const event = entry.event || 'an event occurred';
                const canonText = `<span style="white-space: normal;"><span style="font-weight: 500;">${escapeHtml(name)}</span> <span style="font-style: italic; color: var(--text-secondary);">${escapeHtml(event)}</span></span>`;
                
                row.innerHTML = `
                    <div class="cell avatar">${avatarImg}</div>
                    <div class="cell canon">${canonText}</div>
                    <div class="cell type">${escapeHtml(entry.type)}</div>
                    <div class="cell key">${escapeHtml(entry.key)}</div>
                    <div class="cell epoch">${epochDisplay}</div>
                    <div class="cell edit-cell">
                        <button class="btn btn-secondary" onclick="editEntry(${entry.id}); event.stopPropagation();" style="padding: 4px 8px; font-size: 0.75em;">Edit</button>
                        <button class="btn btn-delete" onclick="showDeleteModal(${entry.id}); event.stopPropagation();" style="padding: 4px 8px; font-size: 0.75em;">Delete</button>
                    </div>
                `;
                container.appendChild(row);
            });
        }
        
        // Search functionality
        document.getElementById('search').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            if (!searchTerm) {
                filteredData = canonData;
            } else {
                filteredData = canonData.filter(entry => {
                    return entry.event.toLowerCase().includes(searchTerm) ||
                           entry.did.toLowerCase().includes(searchTerm) ||
                           entry.type.toLowerCase().includes(searchTerm) ||
                           entry.key.toLowerCase().includes(searchTerm);
                });
            }
            renderTable(filteredData);
            updateCount();
        });
        
        async function handleSubmit(event) {
            event.preventDefault();
            
            const typeSelect = document.getElementById('typeSelect');
            const typeCustom = document.getElementById('typeCustom');
            const type = typeSelect.value === '__custom__' ? typeCustom.value : typeSelect.value;
            
            const keySelect = document.getElementById('keySelect');
            const keyCustom = document.getElementById('keyCustom');
            const key = keySelect.value === '__custom__' ? keyCustom.value : keySelect.value;
            
            if (!type || !key) {
                showStatusInModal('Type and Key are required', 'error');
                return;
            }
            
            const link = document.getElementById('link').value?.trim();
            const didValue = document.getElementById('did').value?.trim();
            let uri = null;
            let url = null;
            
            if (link) {
                if (link.startsWith('at://')) {
                    uri = link;
                } else if (link.includes('bsky.app/profile/') || link.includes('/profile/')) {
                    const match = link.match(/\/post\/([^\/\?]+)/);
                    if (match) {
                        const rkey = match[1];
                        
                        if (didValue && didValue.startsWith('did:')) {
                            uri = `at://${didValue}/app.bsky.feed.post/${rkey}`;
                            url = link;
                        } else {
                            const handleMatch = link.match(/profile\/([^\/]+)\/post/);
                            if (handleMatch) {
                                const handle = handleMatch[1];
                                
                                try {
                                    const resolveResp = await fetch(`https://plc.directory/${handle}`);
                                    if (resolveResp.ok) {
                                        const didDoc = await resolveResp.json();
                                        uri = `at://${didDoc.id}/app.bsky.feed.post/${rkey}`;
                                        url = link;
                                    } else {
                                        url = link;
                                    }
                                } catch (e) {
                                    console.error('Failed to convert URL to URI:', e);
                                    url = link;
                                }
                            } else {
                                url = link;
                            }
                        }
                    } else {
                        url = link;
                    }
                } else if (link.startsWith('http://') || link.startsWith('https://')) {
                    url = link;
                } else {
                    uri = link.includes('://') ? link : `at://${link}`;
                }
            }
            
            const id = document.getElementById('entryId').value;
            const data = {
                did: document.getElementById('did').value,
                event: document.getElementById('event').value,
                type: type,
                key: key,
                uri: uri,
                url: url,
                epoch: document.getElementById('epoch').value ? parseInt(document.getElementById('epoch').value) : Math.floor(Date.now() / 1000)
            };
            
            try {
                const response = await fetch('/api/admin/canon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({
                        id: id || null,
                        ...data
                    })
                });
                
                if (response.ok) {
                    closeModal();
                    await loadCanonEntries();
                    showToast(id ? 'Entry updated successfully' : 'Entry added successfully', 'success');
                } else {
                    const error = await response.json().catch(() => ({}));
                    showStatusInModal(error.error || 'Failed to save entry', 'error');
                }
            } catch (error) {
                console.error('Submit error:', error);
                showStatusInModal('Failed to save entry: ' + error.message, 'error');
            }
        }
        
        function showToast(message, type) {
            const toast = document.createElement('div');
            toast.className = `status-msg ${type}`;
            toast.textContent = message;
            toast.style.position = 'fixed';
            toast.style.top = '100px';
            toast.style.right = '20px';
            toast.style.zIndex = '2000';
            toast.style.minWidth = '300px';
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        
        function showStatusInModal(message, type) {
            const statusMsg = document.getElementById('statusMsg');
            statusMsg.className = `status-msg ${type}`;
            statusMsg.textContent = message;
        }
        
        function formatEpoch(epoch) {
            try {
                const date = new Date(epoch * 1000);
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffDays === 0) {
                    const diffHours = Math.floor(diffMs / 3600000);
                    if (diffHours === 0) {
                        const diffMins = Math.floor(diffMs / 60000);
                        return `${diffMins}m ago`;
                    }
                    return `${diffHours}h ago`;
                }
                if (diffDays === 1) return 'Yesterday';
                if (diffDays < 7) return `${diffDays}d ago`;
                
                return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
            } catch (e) {
                return epoch;
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Close modal on outside click
        document.getElementById('canonModal').addEventListener('click', (e) => {
            if (e.target.id === 'canonModal') {
                closeModal();
            }
        });
    </script>
</body>
</html>
