<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>History - Reverie House</title>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/widgets/header.css">
    <link rel="stylesheet" href="/css/pages/database.css">
    <link rel="stylesheet" href="/css/roles.css">
    <link rel="stylesheet" href="/css/octants.css">
    <link rel="stylesheet" href="/css/color-rows.css">
    <link rel="stylesheet" href="/css/souvenirs.css">
    
    <!-- Favicon and Icons -->
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
    
    <!-- Core utilities (must load first) -->
    <script src="/js/core/world-config-cache.js"></script>
    <script src="/js/core/color-manager.js"></script>
    <script src="/js/core/rowstyle-registry.js"></script>
    <script src="/js/core/rowstyle-engine.js"></script>
    
    <!-- Header and drawer widgets -->
    <script src="/js/widgets/header.js" defer></script>
    <script type="module" src="/js/widgets/oauth-manager.js"></script>
    <script src="/js/widgets/drawer.js" defer></script>
    <script src="/js/widgets/konami.js" defer></script>
    
    <style>
        .modal-overlay {
            display: none !important;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.active {
            display: flex !important;
        }
        
        .canon-modal-content {
            background: white;
            border-radius: 0;
            border: 1.5px solid var(--border);
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            z-index: 100000;
        }
        
        .modal-header {
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1.5px solid var(--border);
        }
        
        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-dark);
            margin: 0;
            font-family: monospace;
        }
        
        .form-group {
            margin-bottom: 0.9rem;
        }
        
        .form-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.3rem;
            font-family: monospace;
        }
        
        .form-input {
            width: 100%;
            padding: 6px 8px;
            border: 1.5px solid var(--border);
            border-radius: 0;
            font-family: monospace;
            font-size: 0.8rem;
            background: var(--bg-white);
            color: var(--text);
            box-sizing: border-box;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-light);
        }
        
        .form-help {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.2rem;
            font-family: monospace;
            font-style: italic;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .input-with-button {
            display: flex;
            gap: 0.5rem;
        }
        
        .input-with-button .form-input {
            flex: 1;
        }
        
        .input-with-button .btn-small {
            padding: 6px 10px;
            font-size: 0.75rem;
            white-space: nowrap;
            border: 1.5px solid var(--border);
            background: var(--bg-white);
            color: var(--text);
            font-family: monospace;
            cursor: pointer;
        }
        
        .input-with-button .btn-small:hover {
            background: var(--bg-light);
            border-color: var(--primary);
        }
        
        .autocomplete-container {
            position: relative;
        }
        
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1.5px solid var(--border);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-suggestions.active {
            display: block;
        }
        
        .autocomplete-item {
            padding: 6px 8px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        .autocomplete-item:hover {
            background: var(--bg-light);
        }
        
        .autocomplete-item .item-name {
            font-weight: 600;
            color: var(--text);
        }
        
        .autocomplete-item .item-handle {
            color: var(--text-dim);
            font-size: 0.7rem;
        }
        
        .modal-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.25rem;
            padding-top: 0.75rem;
            border-top: 1.5px solid var(--border);
        }
        
        .status-msg {
            padding: 0.75rem 1rem;
            border-radius: 0;
            margin-bottom: 1rem;
            font-size: 0.85rem;
            font-family: monospace;
        }
        
        .status-msg.success {
            background: #d1fae5;
            color: #065f46;
            border: 1.5px solid #10b981;
        }
        
        .status-msg.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1.5px solid #ef4444;
        }
        
        .row-entry .cell.edit-cell {
            flex: 0 0 140px;
            max-width: 140px;
            min-width: 140px;
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
        }
        
        .confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99999;
            align-items: center;
            justify-content: center;
        }
        
        .confirm-modal.active {
            display: flex;
        }
        
        .confirm-modal-content {
            background: white;
            border: 1.5px solid var(--border);
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .confirm-modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-dark);
            margin: 0 0 1rem 0;
            font-family: monospace;
        }
        
        .confirm-modal-message {
            font-family: monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text);
            margin-bottom: 1.5rem;
        }
        
        .confirm-modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        
        .btn-delete {
            background: #dc2626;
            color: white;
            border: 1.5px solid #b91c1c;
        }
        
        .btn-delete:hover {
            background: #b91c1c;
        }
        
        /* Bulk deletion styles */
        .bulk-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: #fef3c7;
            border: 1.5px solid #f59e0b;
            margin-bottom: 1rem;
            font-family: monospace;
        }
        
        .bulk-actions.hidden {
            display: none;
        }
        
        .bulk-actions-text {
            font-size: 0.9rem;
            color: #92400e;
            font-weight: 600;
        }
        
        .btn-bulk-delete {
            background: #dc2626;
            color: white;
            border: 1.5px solid #b91c1c;
            padding: 6px 12px;
            font-size: 0.85rem;
            font-family: monospace;
            cursor: pointer;
            font-weight: 600;
        }
        
        .btn-bulk-delete:hover {
            background: #b91c1c;
        }
        
        .btn-bulk-cancel {
            background: transparent;
            color: #92400e;
            border: 1.5px solid #f59e0b;
            padding: 6px 12px;
            font-size: 0.85rem;
            font-family: monospace;
            cursor: pointer;
        }
        
        .btn-bulk-cancel:hover {
            background: #fef3c7;
        }
        
        .row-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .header-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .cell.checkbox-cell {
            flex: 0 0 40px;
            max-width: 40px;
            min-width: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Admin history specific layout - no left sidebar */
        .admin-history-layout {
            padding-left: 0;
        }
        
        .admin-history-layout .database-main-content {
            max-width: 100%;
        }
        
        /* Override first cell padding for checkbox column */
        .admin-history-layout .row-header .cell:first-child,
        .admin-history-layout .row-entry .cell:first-child {
            padding-left: 12px;
        }
        
        /* Scrollable rows container */
        #rows-container {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 100px;
        }
    </style>
</head>
<body class="database-page">
    <div id="header-container"></div>
    
    <div class="database-layout admin-history-layout">
        <main class="database-main-content" style="flex: 1;">
            <header class="page-header-fixed">
                <button class="db-btn" onclick="loadCanonEntries()" title="Refresh data" style="padding:6px 8px;">
                    <svg class="db-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px; height:16px;">
                        <path d="M23 4v6h-6M1 20v-6h6M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                    </svg>
                </button>
                <select id="filter-type" onchange="applyFilters()" class="db-filter-dropdown">
                    <option value="all">All Events</option>
                    <optgroup label="Canon Events">
                        <option value="key:canon">Canon Events</option>
                        <option value="type:dream">Dreams</option>
                        <option value="type:nightmare">Nightmares</option>
                    </optgroup>
                    <optgroup label="Achievements">
                        <option value="type:souvenir">Souvenirs</option>
                        <option value="type:order">Orders</option>
                    </optgroup>
                    <optgroup label="Other">
                        <option value="type:work">Workers</option>
                        <option value="type:name">Name Changes</option>
                        <option value="type:lore">Lore</option>
                    </optgroup>
                </select>
                <input type="text" id="search" placeholder="Search canon history..." class="db-search-input" oninput="applyFilters()">
                <button class="db-btn btn-primary" onclick="showAddModal()" style="margin-left: auto;">+ Add Record</button>
                <div id="recordCount" style="font-family: monospace; font-size: 0.85em; color: var(--text-dim); white-space: nowrap; padding-left: 12px;">0 records</div>
            </header>
            
            <div class="bulk-actions hidden" id="bulkActions">
                <span class="bulk-actions-text" id="bulkActionsText">0 selected</span>
                <button class="btn-bulk-delete" onclick="bulkDelete()">Delete Selected</button>
                <button class="btn-bulk-cancel" onclick="clearSelection()">Cancel</button>
            </div>

            <div id="rows-container">
                <!-- Rows will be displayed here -->
            </div>
        </main>
    </div>
    
    <!-- Add/Edit Modal -->
    <div class="modal-overlay" id="canonModal">
        <div class="canon-modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Add Canon Entry</h2>
            </div>
            
            <div id="statusMsg"></div>
            
            <form id="canonForm" onsubmit="handleSubmit(event)">
                <input type="hidden" id="entryId" value="">
                
                <div class="form-group autocomplete-container">
                    <label class="form-label">DID / Handle / Name *</label>
                    <input type="text" class="form-input" id="did" required autocomplete="off">
                    <div class="autocomplete-suggestions" id="didSuggestions"></div>
                    <div class="form-help">Search by DID, handle, or name</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Event *</label>
                    <input type="text" class="form-input" id="event" required>
                    <div class="form-help">Description of the canon event</div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Type *</label>
                        <select class="form-input" id="typeSelect" onchange="handleTypeChange()">
                            <option value="">-- Select Type --</option>
                        </select>
                        <input type="text" class="form-input" id="typeCustom" placeholder="Enter custom type..." style="display: none; margin-top: 0.5rem;">
                        <div class="form-help">Event type</div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Key *</label>
                        <select class="form-input" id="keySelect" onchange="handleKeyChange()">
                            <option value="">-- Select Key --</option>
                        </select>
                        <input type="text" class="form-input" id="keyCustom" placeholder="Enter custom key..." style="display: none; margin-top: 0.5rem;" required>
                        <div class="form-help">Unique key</div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Link (URI or URL)</label>
                    <input type="text" class="form-input" id="link" placeholder="at://... or https://...">
                    <div class="form-help">AT Protocol URI or HTTP URL - auto-detected</div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Epoch</label>
                    <div class="input-with-button">
                        <input type="number" class="form-input" id="epoch" value="">
                        <button type="button" class="btn-small" onclick="setEpochFromLink()">Post Time</button>
                        <button type="button" class="btn-small" onclick="setEpochNow()">Now Time</button>
                    </div>
                    <div class="form-help">Unix timestamp</div>
                </div>
                
                <div class="modal-actions">
                    <button type="submit" class="btn btn-primary">Save</button>
                    <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div class="confirm-modal" id="deleteModal">
        <div class="confirm-modal-content">
            <h2 class="confirm-modal-title" id="deleteModalTitle">Delete Canon Entry?</h2>
            <div class="confirm-modal-message" id="deleteMessage">
                Are you sure you want to delete this canon entry? This action cannot be undone.
            </div>
            <div class="confirm-modal-actions">
                <button type="button" class="btn btn-delete" id="confirmDeleteBtn" onclick="confirmDelete()">Delete</button>
                <button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Global functions (must be accessible from onclick handlers)
        
        function showAddModal() {
            document.getElementById('modalTitle').textContent = 'Add Canon Entry';
            document.getElementById('canonForm').reset();
            document.getElementById('entryId').value = '';
            document.getElementById('statusMsg').innerHTML = '';
            document.getElementById('canonModal').classList.add('active');
        }
        
        function closeModal() {
            document.getElementById('canonModal').classList.remove('active');
            document.getElementById('didSuggestions').classList.remove('active');
        }
        
        // Delete modal functions
        let deleteEntryId = null;
        let deleteIsBulk = false;
        let selectedIds = new Set();
        
        function showDeleteModal(id) {
            if (!id || id === 'undefined') {
                console.error('Invalid ID passed to showDeleteModal:', id);
                showToast('Error: Invalid entry ID', 'error');
                return;
            }
            
            const entry = canonData.find(e => e.id === id);
            if (!entry) {
                console.error('Entry not found for ID:', id);
                showToast('Error: Entry not found', 'error');
                return;
            }
            
            deleteEntryId = id;
            deleteIsBulk = false;
            const name = entry.name || 'Unknown';
            const event = entry.event || 'unknown event';
            
            console.log('Opening delete modal for entry:', id, entry);
            
            document.getElementById('deleteModalTitle').textContent = 'Delete Canon Entry?';
            document.getElementById('deleteMessage').innerHTML = `
                Are you sure you want to delete this canon entry?<br><br>
                <strong>${escapeHtml(name)}</strong> <em>${escapeHtml(event)}</em><br><br>
                This action cannot be undone.
            `;
            document.getElementById('confirmDeleteBtn').textContent = 'Delete';
            document.getElementById('deleteModal').classList.add('active');
        }
        
        function closeDeleteModal() {
            document.getElementById('deleteModal').classList.remove('active');
            deleteEntryId = null;
            deleteIsBulk = false;
        }
        
        async function confirmDelete() {
            if (deleteIsBulk) {
                // Bulk delete
                const idsToDelete = Array.from(selectedIds);
                if (idsToDelete.length === 0) {
                    console.warn('No IDs selected for bulk delete');
                    closeDeleteModal();
                    return;
                }
                
                try {
                    let successCount = 0;
                    let failCount = 0;
                    
                    for (const id of idsToDelete) {
                        if (!id || id === 'undefined') {
                            console.error('Invalid ID in bulk delete:', id);
                            failCount++;
                            continue;
                        }
                        
                        try {
                            const response = await fetch(`/api/admin/canon/${id}`, {
                                method: 'DELETE',
                                headers: {
                                    'Authorization': `Bearer ${adminToken}`
                                }
                            });
                            
                            if (response.ok) {
                                successCount++;
                            } else {
                                failCount++;
                            }
                        } catch (error) {
                            console.error(`Failed to delete entry ${id}:`, error);
                            failCount++;
                        }
                    }
                    
                    closeDeleteModal();
                    clearSelection();
                    await loadCanonEntries();
                    
                    if (failCount === 0) {
                        showToast(`${successCount} entries deleted successfully`, 'success');
                    } else {
                        showToast(`${successCount} deleted, ${failCount} failed`, 'error');
                    }
                } catch (error) {
                    console.error('Bulk delete error:', error);
                    showToast('Failed to delete entries: ' + error.message, 'error');
                }
            } else {
                // Single delete
                if (!deleteEntryId || deleteEntryId === 'undefined') {
                    console.error('Invalid deleteEntryId:', deleteEntryId);
                    closeDeleteModal();
                    showToast('Error: Invalid entry ID', 'error');
                    return;
                }
                
                try {
                    console.log('Deleting entry:', deleteEntryId);
                    const response = await fetch(`/api/admin/canon/${deleteEntryId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${adminToken}`
                        }
                    });
                    
                    if (response.ok) {
                        closeDeleteModal();
                        await loadCanonEntries();
                        showToast('Entry deleted successfully', 'success');
                    } else {
                        const error = await response.json().catch(() => ({}));
                        closeDeleteModal();
                        showToast(error.error || 'Failed to delete entry', 'error');
                    }
                } catch (error) {
                    console.error('Delete error:', error);
                    closeDeleteModal();
                    showToast('Failed to delete entry: ' + error.message, 'error');
                }
            }
        }
        
        function bulkDelete() {
            const count = selectedIds.size;
            if (count === 0) return;
            
            deleteIsBulk = true;
            document.getElementById('deleteModalTitle').textContent = 'Delete Multiple Entries?';
            document.getElementById('deleteMessage').innerHTML = `
                Are you sure you want to delete <strong>${count}</strong> canon ${count === 1 ? 'entry' : 'entries'}?<br><br>
                This action cannot be undone.
            `;
            document.getElementById('confirmDeleteBtn').textContent = `Delete ${count} ${count === 1 ? 'Entry' : 'Entries'}`;
            document.getElementById('deleteModal').classList.add('active');
        }
        
        function clearSelection() {
            selectedIds.clear();
            updateBulkActions();
            document.querySelectorAll('.row-checkbox').forEach(cb => cb.checked = false);
            const headerCb = document.getElementById('headerCheckbox');
            if (headerCb) headerCb.checked = false;
        }
        
        function updateBulkActions() {
            const bulkActions = document.getElementById('bulkActions');
            const bulkText = document.getElementById('bulkActionsText');
            const count = selectedIds.size;
            
            if (count > 0) {
                bulkActions.classList.remove('hidden');
                bulkText.textContent = `${count} selected`;
            } else {
                bulkActions.classList.add('hidden');
            }
        }
        
        function toggleRowSelection(id, checked) {
            console.log('toggleRowSelection called:', {id, checked, type: typeof id});
            
            // Validate ID
            if (id === undefined || id === null || id === 'undefined' || id === 'null') {
                console.error('Invalid ID in toggleRowSelection:', id);
                return;
            }
            
            // Ensure ID is a number
            const numId = typeof id === 'number' ? id : parseInt(id, 10);
            if (isNaN(numId)) {
                console.error('ID is not a valid number:', id);
                return;
            }
            
            if (checked) {
                selectedIds.add(numId);
                console.log('Added to selection:', numId);
            } else {
                selectedIds.delete(numId);
                console.log('Removed from selection:', numId);
            }
            
            console.log('Current selectedIds:', Array.from(selectedIds));
            updateBulkActions();
        }
        
        function toggleAllRows(checked) {
            console.log('toggleAllRows called:', checked);
            const checkboxes = document.querySelectorAll('.row-checkbox');
            console.log('Found checkboxes:', checkboxes.length);
            
            checkboxes.forEach(cb => {
                cb.checked = checked;
                const idStr = cb.dataset.id;
                console.log('Processing checkbox with data-id:', idStr);
                
                if (!idStr || idStr === 'undefined' || idStr === 'null') {
                    console.error('Invalid data-id on checkbox:', cb);
                    return;
                }
                
                const id = parseInt(idStr, 10);
                if (isNaN(id)) {
                    console.error('Could not parse ID as number:', idStr);
                    return;
                }
                
                if (checked) {
                    selectedIds.add(id);
                } else {
                    selectedIds.delete(id);
                }
            });
            
            console.log('After toggleAll, selectedIds:', Array.from(selectedIds));
            updateBulkActions();
        }
        
        function handleTypeChange() {
            const select = document.getElementById('typeSelect');
            const customInput = document.getElementById('typeCustom');
            
            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.required = true;
            } else {
                customInput.style.display = 'none';
                customInput.required = false;
            }
        }
        
        function handleKeyChange() {
            const select = document.getElementById('keySelect');
            const customInput = document.getElementById('keyCustom');
            
            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.required = true;
            } else {
                customInput.style.display = 'none';
                customInput.required = false;
            }
        }
        
        function setEpochNow() {
            document.getElementById('epoch').value = Math.floor(Date.now() / 1000);
        }
        
        async function setEpochFromLink() {
            const link = document.getElementById('link').value;
            
            if (!link) {
                alert('Please enter a link first');
                return;
            }
            
            let atUri = '';
            let did = '';
            
            if (link.startsWith('at://')) {
                atUri = link;
                const match = atUri.match(/^at:\/\/(did:[^\/]+)/);
                if (match) {
                    did = match[1];
                }
            } else if (link.includes('bsky.app/profile/') || link.includes('/profile/')) {
                const match = link.match(/profile\/([^\/]+)\/post\/([^\/\?]+)/);
                if (match) {
                    const handle = match[1];
                    const rkey = match[2];
                    
                    try {
                        // First resolve handle to DID using Bluesky's API
                        const resolveResp = await fetch(`https://bsky.social/xrpc/com.atproto.identity.resolveHandle?handle=${handle}`);
                        if (!resolveResp.ok) {
                            throw new Error('Handle not found');
                        }
                        const resolveData = await resolveResp.json();
                        did = resolveData.did;
                        atUri = `at://${did}/app.bsky.feed.post/${rkey}`;
                    } catch (e) {
                        console.error('Failed to resolve handle via Bluesky:', e);
                        alert('Could not resolve handle: ' + handle);
                        return;
                    }
                } else {
                    alert('Invalid post URL format');
                    return;
                }
            } else {
                alert('Link must be an AT URI (at://...) or post URL');
                return;
            }
            
            let pdsEndpoint = '';
            try {
                const didDocResp = await fetch(`https://plc.directory/${did}`);
                const didDoc = await didDocResp.json();
                
                const pdsService = didDoc.service?.find(s => s.id === '#atproto_pds');
                if (pdsService) {
                    pdsEndpoint = pdsService.serviceEndpoint;
                } else {
                    throw new Error('No PDS endpoint found in DID document');
                }
            } catch (e) {
                console.error('Failed to get DID document:', e);
                alert('Could not find PDS for this user');
                return;
            }
            
            try {
                const parts = atUri.replace('at://', '').split('/');
                const collection = parts[1];
                const rkey = parts[2];
                
                const url = `${pdsEndpoint}/xrpc/com.atproto.repo.getRecord?repo=${did}&collection=${collection}&rkey=${rkey}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.value && data.value.createdAt) {
                    const createdAt = new Date(data.value.createdAt);
                    const epoch = Math.floor(createdAt.getTime() / 1000);
                    document.getElementById('epoch').value = epoch;
                } else {
                    alert('Could not find createdAt timestamp in record');
                }
            } catch (e) {
                console.error('Failed to fetch record:', e);
                alert('Failed to fetch post data: ' + e.message);
            }
        }
        
        function closeModal() {
            document.getElementById('canonModal').classList.remove('active');
        }
        
        function editEntry(id) {
            const entry = canonData.find(e => e.id === id);
            if (!entry) return;
            
            document.getElementById('modalTitle').textContent = 'Edit Canon Entry';
            document.getElementById('entryId').value = entry.id;
            document.getElementById('did').value = entry.did;
            document.getElementById('event').value = entry.event;
            
            // Set type dropdown
            const typeSelect = document.getElementById('typeSelect');
            const typeCustom = document.getElementById('typeCustom');
            const typeOption = Array.from(typeSelect.options).find(opt => opt.value === entry.type);
            
            if (typeOption) {
                typeSelect.value = entry.type;
                typeCustom.style.display = 'none';
                typeCustom.required = false;
            } else {
                typeSelect.value = '__custom__';
                typeCustom.value = entry.type;
                typeCustom.style.display = 'block';
                typeCustom.required = true;
            }
            
            // Set key dropdown
            const keySelect = document.getElementById('keySelect');
            const keyCustom = document.getElementById('keyCustom');
            const keyOption = Array.from(keySelect.options).find(opt => opt.value === entry.key);
            
            if (keyOption) {
                keySelect.value = entry.key;
                keyCustom.style.display = 'none';
                keyCustom.required = false;
            } else {
                keySelect.value = '__custom__';
                keyCustom.value = entry.key;
                keyCustom.style.display = 'block';
                keyCustom.required = true;
            }
            
            // Set link field (prefer URI over URL)
            document.getElementById('link').value = entry.uri || entry.url || '';
            document.getElementById('epoch').value = entry.epoch || '';
            document.getElementById('statusMsg').innerHTML = '';
            document.getElementById('canonModal').classList.add('active');
        }
        
        // Authentication & Authorization
        
        const adminToken = localStorage.getItem('admin_token');
        
        if (!adminToken) {
            window.location.href = '/admin/login.html';
        } else {
            fetch('/api/admin/verify', {
                headers: {
                    'Authorization': `Bearer ${adminToken}`
                }
            }).then(response => {
                if (!response.ok) {
                    localStorage.removeItem('admin_token');
                    window.location.href = '/admin/login.html';
                } else {
                    return response.json();
                }
            }).then(data => {
                if (data) {
                    const adminSession = {
                        did: data.did,
                        handle: data.handle,
                        displayName: data.handle,
                        isAdmin: true
                    };
                    
                    sessionStorage.setItem('admin_session', JSON.stringify(adminSession));
                    
                    window.dispatchEvent(new CustomEvent('oauth:login', {
                        detail: { session: adminSession }
                    }));
                    
                    loadCanonEntries();
                }
            }).catch(error => {
                console.error('Auth check failed:', error);
                localStorage.removeItem('admin_token');
                window.location.href = '/admin/login.html';
            });
        }
        
        // Canon Management
        
        let canonData = [];
        let filteredData = [];
        let dreamersCache = [];
        
        async function loadCanonEntries() {
            try {
                const response = await fetch('/api/canon');
                canonData = await response.json();
                console.log('Loaded canon data:', canonData.length, 'entries');
                console.log('Sample entry:', canonData[0]);
                
                // Validate all entries have IDs
                const missingIds = canonData.filter(e => !e.id && e.id !== 0);
                if (missingIds.length > 0) {
                    console.error('Entries without IDs:', missingIds);
                }
                
                filteredData = canonData;
                renderTable(filteredData);
                updateCount();
                populateDropdowns();
            } catch (error) {
                console.error('Failed to load canon entries:', error);
                document.getElementById('rows-container').innerHTML = 
                    '<div style="text-align: center; padding: 3rem; color: #ef4444; font-family: monospace;">Failed to load canon history</div>';
            }
        }
        
        function populateDropdowns() {
            // Get unique types and keys
            const types = [...new Set(canonData.map(e => e.type).filter(Boolean))];
            const keys = [...new Set(canonData.map(e => e.key).filter(Boolean))];
            
            const typeSelect = document.getElementById('typeSelect');
            const keySelect = document.getElementById('keySelect');
            
            // Clear and populate type dropdown
            typeSelect.innerHTML = '<option value="">-- Select Type --</option>';
            types.forEach(type => {
                typeSelect.innerHTML += `<option value="${escapeHtml(type)}">${escapeHtml(type)}</option>`;
            });
            typeSelect.innerHTML += '<option value="__custom__">+ Enter Custom Type</option>';
            
            keySelect.innerHTML = '<option value="">-- Select Key --</option>';
            keys.forEach(key => {
                keySelect.innerHTML += `<option value="${escapeHtml(key)}">${escapeHtml(key)}</option>`;
            });
            keySelect.innerHTML += '<option value="__custom__">+ Enter Custom Key</option>';
        }
        
        // DID autocomplete
        let didAutocompleteTimeout;
        document.addEventListener('DOMContentLoaded', () => {
            const didInput = document.getElementById('did');
            const suggestions = document.getElementById('didSuggestions');
            
            didInput.addEventListener('input', (e) => {
                clearTimeout(didAutocompleteTimeout);
                const query = e.target.value.trim();
                
                if (query.length < 2) {
                    suggestions.classList.remove('active');
                    return;
                }
                
                didAutocompleteTimeout = setTimeout(async () => {
                    await searchDreamers(query);
                }, 300);
            });
            
            didInput.addEventListener('blur', () => {
                setTimeout(() => suggestions.classList.remove('active'), 200);
            });
        });
        
        async function searchDreamers(query) {
            try {
                const lowerQuery = query.toLowerCase();
                const matches = canonData
                    .filter(entry => {
                        const did = entry.did?.toLowerCase() || '';
                        const name = entry.name?.toLowerCase() || '';
                        const handle = entry.handle?.toLowerCase() || '';
                        return did.includes(lowerQuery) || name.includes(lowerQuery) || handle.includes(lowerQuery);
                    })
                    .map(entry => ({
                        did: entry.did,
                        name: entry.name || 'Unknown',
                        handle: entry.handle || ''
                    }));
                
                const uniqueMatches = [];
                const seenDids = new Set();
                for (const match of matches) {
                    if (!seenDids.has(match.did)) {
                        seenDids.add(match.did);
                        uniqueMatches.push(match);
                    }
                }
                
                const suggestions = document.getElementById('didSuggestions');
                suggestions.innerHTML = '';
                
                if (uniqueMatches.length === 0) {
                    suggestions.classList.remove('active');
                    return;
                }
                
                uniqueMatches.slice(0, 10).forEach(dreamer => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `
                        <div class="item-name">${escapeHtml(dreamer.name)}</div>
                        <div class="item-handle">${dreamer.handle ? '@' + escapeHtml(dreamer.handle) + ' â€¢ ' : ''}${escapeHtml(dreamer.did)}</div>
                    `;
                    item.onclick = () => selectDreamer(dreamer);
                    suggestions.appendChild(item);
                });
                
                suggestions.classList.add('active');
            } catch (error) {
                console.error('Failed to search dreamers:', error);
            }
        }
        
        function selectDreamer(dreamer) {
            document.getElementById('did').value = dreamer.did;
            document.getElementById('didSuggestions').classList.remove('active');
        }
        
        function updateCount() {
            document.getElementById('recordCount').textContent = `${filteredData.length} records`;
        }
        
        function renderTable(data) {
            const container = document.getElementById('rows-container');
            container.innerHTML = '';
            
            // Initialize RowStyleEngine if not already done
            if (!window.rowStyleEngine && window.RowStyleEngine) {
                window.rowStyleEngine = new RowStyleEngine();
            }
            
            if (data.length === 0) {
                container.innerHTML = '<div class="row-entry" style="text-align: center; display: block; font-style: italic; color: var(--text-dim);">No canon entries found</div>';
                return;
            }
            
            // Build header row
            container.innerHTML = `
                <div class="row-header">
                    <div class="cell checkbox-cell">
                        <input type="checkbox" class="header-checkbox" id="headerCheckbox" onchange="toggleAllRows(this.checked)">
                    </div>
                    <div class="cell type">Type</div>
                    <div class="cell epoch">Date</div>
                    <div class="cell avatar"></div>
                    <div class="cell canon">Canon Event</div>
                    <div class="cell key">Key</div>
                    <div class="cell edit-cell">Actions</div>
                </div>
            `;
            
            data.forEach(entry => {
                // Validate entry has an ID
                if (!entry.id && entry.id !== 0) {
                    console.error('Entry missing ID:', entry);
                    return; // Skip this entry
                }
                
                // Get rowstyle classes if RowStyleEngine is available
                let rowClasses = 'row-entry';
                let rowStyles = '';
                if (window.rowStyleEngine) {
                    rowClasses = window.rowStyleEngine.getRowClasses(entry);
                    rowStyles = window.rowStyleEngine.getRowStyles(entry);
                }
                
                const row = document.createElement('div');
                row.className = rowClasses;
                if (rowStyles) {
                    row.setAttribute('style', rowStyles);
                }
                
                // Format epoch similar to EventStack
                const epoch = entry.epoch || 0;
                const date = new Date(epoch * 1000);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                const dateStr = `${day}/${month}/${year}`;
                
                const avatarImg = entry.avatar ? 
                    `<img src="${entry.avatar}" class="avatar-img" alt="avatar" onerror="this.src='/assets/icon_face.png'">` :
                    '<img src="/assets/icon_face.png" class="avatar-img" alt="avatar">';
                
                const name = entry.name || 'unknown';
                const eventText = entry.event || 'an event occurred';
                const did = entry.did || '';
                
                const isChecked = selectedIds.has(entry.id) ? 'checked' : '';
                
                // Build dreamer link for name if DID exists
                const nameHtml = did ? 
                    `<a href="/dreamer?did=${encodeURIComponent(did)}" class="dreamer-link" onclick="event.stopPropagation()" style="font-weight: 500; color: inherit; text-decoration: none;">${escapeHtml(name)}</a>` : 
                    `<span style="font-weight: 500;">${escapeHtml(name)}</span>`;
                
                row.innerHTML = `
                    <div class="cell checkbox-cell">
                        <input type="checkbox" class="row-checkbox" data-id="${entry.id}" onchange="toggleRowSelection(${entry.id}, this.checked)" ${isChecked}>
                    </div>
                    <div class="cell type" style="padding-left: 12px; padding-right: 6px;">
                        <span style="font-size: 0.85em; text-transform: lowercase;">${escapeHtml(entry.type || '')}</span>
                    </div>
                    <div class="cell epoch" style="padding: 0 2px; min-width: 56px; max-width: 64px; text-align: left; padding-left: 6px; padding-right: 6px;">${dateStr}</div>
                    <div class="cell avatar">${avatarImg}</div>
                    <div class="cell canon" style="padding-left: 12px;">
                        <span style="white-space: normal;">${nameHtml} <span style="font-style: italic; color: var(--text-secondary);">${escapeHtml(eventText)}</span></span>
                    </div>
                    <div class="cell key">
                        <span style="font-size: 0.85em; font-family: monospace;">${escapeHtml(entry.key || '')}</span>
                    </div>
                    <div class="cell edit-cell">
                        <button class="btn btn-secondary" onclick="editEntry(${entry.id}); event.stopPropagation();" style="padding: 4px 8px; font-size: 0.75em;">Edit</button>
                        <button class="btn btn-delete" onclick="showDeleteModal(${entry.id}); event.stopPropagation();" style="padding: 4px 8px; font-size: 0.75em;">Delete</button>
                    </div>
                `;
                container.appendChild(row);
            });
            
            // Apply effects using RowStyle engine
            if (window.rowStyleEngine) {
                window.rowStyleEngine.applyEffects(container);
            }
        }
        
        // Filter functionality
        function applyFilters() {
            const filterValue = document.getElementById('filter-type').value;
            const searchQuery = document.getElementById('search').value.toLowerCase().trim();
            
            let data = canonData;
            
            // Apply type/key filter
            if (filterValue !== 'all') {
                if (filterValue.includes(':')) {
                    const [field, value] = filterValue.split(':');
                    data = data.filter(entry => entry[field] === value);
                } else {
                    data = data.filter(entry => entry.type === filterValue || entry.key === filterValue);
                }
            }
            
            // Apply search filter
            if (searchQuery) {
                data = data.filter(entry => {
                    return (entry.event?.toLowerCase().includes(searchQuery)) ||
                           (entry.did?.toLowerCase().includes(searchQuery)) ||
                           (entry.type?.toLowerCase().includes(searchQuery)) ||
                           (entry.key?.toLowerCase().includes(searchQuery)) ||
                           (entry.name?.toLowerCase().includes(searchQuery));
                });
            }
            
            filteredData = data;
            renderTable(filteredData);
            updateCount();
        }
        
        async function handleSubmit(event) {
            event.preventDefault();
            
            const typeSelect = document.getElementById('typeSelect');
            const typeCustom = document.getElementById('typeCustom');
            const type = typeSelect.value === '__custom__' ? typeCustom.value : typeSelect.value;
            
            const keySelect = document.getElementById('keySelect');
            const keyCustom = document.getElementById('keyCustom');
            const key = keySelect.value === '__custom__' ? keyCustom.value : keySelect.value;
            
            if (!type || !key) {
                showStatusInModal('Type and Key are required', 'error');
                return;
            }
            
            const link = document.getElementById('link').value?.trim();
            const didValue = document.getElementById('did').value?.trim();
            let uri = null;
            let url = null;
            
            if (link) {
                if (link.startsWith('at://')) {
                    uri = link;
                } else if (link.includes('bsky.app/profile/') || link.includes('/profile/')) {
                    const match = link.match(/\/post\/([^\/\?]+)/);
                    if (match) {
                        const rkey = match[1];
                        
                        if (didValue && didValue.startsWith('did:')) {
                            uri = `at://${didValue}/app.bsky.feed.post/${rkey}`;
                            url = link;
                        } else {
                            const handleMatch = link.match(/profile\/([^\/]+)\/post/);
                            if (handleMatch) {
                                const handle = handleMatch[1];
                                
                                try {
                                    const resolveResp = await fetch(`https://plc.directory/${handle}`);
                                    if (resolveResp.ok) {
                                        const didDoc = await resolveResp.json();
                                        uri = `at://${didDoc.id}/app.bsky.feed.post/${rkey}`;
                                        url = link;
                                    } else {
                                        url = link;
                                    }
                                } catch (e) {
                                    console.error('Failed to convert URL to URI:', e);
                                    url = link;
                                }
                            } else {
                                url = link;
                            }
                        }
                    } else {
                        url = link;
                    }
                } else if (link.startsWith('http://') || link.startsWith('https://')) {
                    url = link;
                } else {
                    uri = link.includes('://') ? link : `at://${link}`;
                }
            }
            
            const id = document.getElementById('entryId').value;
            const data = {
                did: document.getElementById('did').value,
                event: document.getElementById('event').value,
                type: type,
                key: key,
                uri: uri,
                url: url,
                epoch: document.getElementById('epoch').value ? parseInt(document.getElementById('epoch').value) : Math.floor(Date.now() / 1000)
            };
            
            try {
                const response = await fetch('/api/admin/canon', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({
                        id: id || null,
                        ...data
                    })
                });
                
                if (response.ok) {
                    closeModal();
                    await loadCanonEntries();
                    showToast(id ? 'Entry updated successfully' : 'Entry added successfully', 'success');
                } else {
                    const error = await response.json().catch(() => ({}));
                    showStatusInModal(error.error || 'Failed to save entry', 'error');
                }
            } catch (error) {
                console.error('Submit error:', error);
                showStatusInModal('Failed to save entry: ' + error.message, 'error');
            }
        }
        
        function showToast(message, type) {
            const toast = document.createElement('div');
            toast.className = `status-msg ${type}`;
            toast.textContent = message;
            toast.style.position = 'fixed';
            toast.style.top = '100px';
            toast.style.right = '20px';
            toast.style.zIndex = '2000';
            toast.style.minWidth = '300px';
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        
        function showStatusInModal(message, type) {
            const statusMsg = document.getElementById('statusMsg');
            statusMsg.className = `status-msg ${type}`;
            statusMsg.textContent = message;
        }
        
        function formatEpoch(epoch) {
            try {
                const date = new Date(epoch * 1000);
                const now = new Date();
                const diffMs = now - date;
                const diffDays = Math.floor(diffMs / 86400000);
                
                if (diffDays === 0) {
                    const diffHours = Math.floor(diffMs / 3600000);
                    if (diffHours === 0) {
                        const diffMins = Math.floor(diffMs / 60000);
                        return `${diffMins}m ago`;
                    }
                    return `${diffHours}h ago`;
                }
                if (diffDays === 1) return 'Yesterday';
                if (diffDays < 7) return `${diffDays}d ago`;
                
                return date.toLocaleDateString('en-US', { 
                    year: 'numeric', 
                    month: 'short', 
                    day: 'numeric' 
                });
            } catch (e) {
                return epoch;
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Close modal on outside click
        document.getElementById('canonModal').addEventListener('click', (e) => {
            if (e.target.id === 'canonModal') {
                closeModal();
            }
        });
        
        document.getElementById('deleteModal').addEventListener('click', (e) => {
            if (e.target.id === 'deleteModal') {
                closeDeleteModal();
            }
        });
    </script>
</body>
</html>
