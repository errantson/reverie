
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverie House â€” Souvenirs</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Collect souvenirs as mementoes of your journey through our wild mindscape, marking your adventures and unlocking more.">
    <meta name="keywords" content="souvenirs, badges, achievements, collectibles, dreamweaving, reverie house">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://reverie.house/souvenirs.html">
    <meta property="og:title" content="Souvenirs - Reverie House">
    <meta property="og:description" content="Collect souvenirs as mementoes of your journey through our wild mindscape, marking your adventures and unlocking more.">
    <meta property="og:image" content="https://reverie.house/assets/og-image.png">
    <meta property="og:site_name" content="Reverie House">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Souvenirs - Reverie House">
    <meta name="twitter:description" content="Collect souvenirs as mementoes of your journey through our wild mindscape, marking your adventures and unlocking more.">
    <meta name="twitter:image" content="https://reverie.house/assets/og-image.png">
    
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/pages/souvenirs-desktop.css">
    <link rel="stylesheet" href="css/pages/database.css">
    <link rel="stylesheet" href="css/roles.css">
    <link rel="stylesheet" href="css/octants.css">
    <link rel="stylesheet" href="css/souvenirs.css">
    <link rel="stylesheet" href="css/color-rows.css">
    <link rel="stylesheet" href="css/widgets/login.css">
    <link rel="stylesheet" href="css/widgets/dialogue.css">
    <link rel="stylesheet" href="css/widgets/dreamer-hover.css">
    <link rel="icon" href="/assets/favicon.ico" type="image/x-icon">
    <!-- Core utilities (must load first) -->
    <script src="js/core/world-config-cache.js"></script>
    <script src="js/core/color-manager.js"></script>
    <script src="js/utils/shadowbox.js"></script>
    <script src="js/widgets/showpost.js"></script>
    <script src="js/widgets/background.js"></script>
    <script src="js/utils/num_nom.js"></script>
    <script src="js/widgets/souvenirs.js"></script>
    <script src="js/widgets/header.js" defer></script>
    <script type="module" src="js/widgets/oauth-manager.js"></script>
    <script src="js/widgets/login.js" defer></script>
    <script src="js/widgets/dreamer-hover.js" defer></script>
    <script src="js/widgets/drawer.js" defer></script>
    <script src="js/widgets/konami.js" defer></script>
    <!-- Souvenir widgets -->
    <script src="js/widgets/eventstack.js"></script>
</head>
<body class="souvenir-page">
    <div id="header-container"></div>
    
    <!-- Full-Screen Background Scene -->
    <div class="fullscreen-background">
        <div class="scene-background">
            <img src="" alt="Souvenir Background" class="scene-layer background-layer">
        </div>
    </div>

    <!-- Main Content Layout -->
    <div id="souvenir-page-container">
        <div class="souvenir-frame" id="souvenir-frame">
            <!-- Souvenir Info Section -->
            <div class="souvenir-info-section">
                <div class="souvenir-icon-bubble" id="souvenir-icon"></div>
                <div class="souvenir-text">
                    <h1 class="souvenir-name" id="souvenir-title">Loading...</h1>
                    <p class="souvenir-description" id="souvenir-description"></p>
                    <p class="souvenir-details" id="souvenir-details"></p>
                </div>
            </div>
            
            <!-- Tab Controls -->
            <div class="souvenir-face-controls">
                <button class="souvenir-face-btn active" data-face="events">
                    <svg class="btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    <span>Events</span>
                </button>
                <button class="souvenir-face-btn" data-face="keepers">
                    <svg class="btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="9" cy="7" r="4"></circle>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                    </svg>
                    <span>Keepers</span>
                </button>
                <button class="souvenir-face-btn" data-face="explore">
                    <svg class="btn-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>
                    </svg>
                    <span>Explore More</span>
                </button>
            </div>
            
            <!-- Content Faces -->
            <div class="souvenir-content-faces">
                <!-- Events Face - Timeline of canon events -->
                <div class="souvenir-events-face active" id="souvenir-events-face"></div>

                <!-- Keepers Face - List of profile holders -->
                <div class="souvenir-keepers-face" id="souvenir-keepers-face">
                    <div class="souvenir-keepers-list" id="keepers-list"></div>
                </div>

                <!-- Explore More Face - Souvenirs Physics Box -->
                <div class="souvenir-explore-face" id="souvenir-explore-face">
                    <div class="souvenirs-physics-container" id="explore-souvenirs-container">
                        <canvas id="explore-souvenirs-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Toggle Visibility Button -->
        <button class="toggle-details-btn" id="toggle-details-btn" aria-label="Toggle details visibility">
            <svg class="eye-icon eye-open" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
            <svg class="eye-icon eye-closed" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                <line x1="1" y1="1" x2="23" y2="23"></line>
            </svg>
        </button>
    </div>

    <script>
        // Get query parameter 'key'
        const params = new URLSearchParams(window.location.search);
        let souvenirKey = params.get('key') || 'residence';
        
        let allSouvenirs = {};
        let currentSouvenir = null;
        
        // Function to update URL without reloading
        function updateURL(key) {
            const url = new URL(window.location);
            url.searchParams.set('key', key);
            window.history.pushState({ souvenirKey: key }, '', url);
        }
        
        // Global function to switch between souvenir faces
        function switchToFace(face) {
            const tabButtons = document.querySelectorAll('.souvenir-face-btn');
            const eventsFace = document.getElementById('souvenir-events-face');
            const keepersFace = document.getElementById('souvenir-keepers-face');
            const exploreFace = document.getElementById('souvenir-explore-face');

            // Update button states
            tabButtons.forEach(b => b.classList.remove('active'));
            const targetBtn = document.querySelector(`.souvenir-face-btn[data-face="${face}"]`);
            if (targetBtn) targetBtn.classList.add('active');

            // Fade out all faces first
            eventsFace.classList.remove('active');
            keepersFace.classList.remove('active');
            exploreFace.classList.remove('active');

            // Small delay for smooth transition, then fade in target
            setTimeout(() => {
                if (face === 'events') {
                    eventsFace.classList.add('active');
                } else if (face === 'keepers') {
                    keepersFace.classList.add('active');
                } else if (face === 'explore') {
                    exploreFace.classList.add('active');
                    initExploreSouvenirs();
                }
            }, 50);

            // Save selection to localStorage
            localStorage.setItem('souvenir-selected-face', face);
        }
        
        // Souvenirs physics variables
        let souvenirsBubbles = [];
        let souvenirsAnimationFrame = null;
        let souvenirsMouseX = 0;
        let souvenirsMouseY = 0;
        let phaneraBgImage = null;
        let phaneraBgAlpha = 1;
        let souvenirsInitialized = false;
        
        // Initialize souvenirs physics for explore face
        async function initExploreSouvenirs() {
            if (souvenirsInitialized) return;
            
            souvenirsInitialized = true;
            
            const canvas = document.getElementById('explore-souvenirs-canvas');
            if (!canvas) return;
            
            const container = document.getElementById('explore-souvenirs-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Stop any existing animation
            if (souvenirsAnimationFrame) {
                cancelAnimationFrame(souvenirsAnimationFrame);
            }
            
            // Setup mouse tracking
            const handleMouseMove = (e) => {
                const rect = canvas.getBoundingClientRect();
                souvenirsMouseX = e.clientX - rect.left;
                souvenirsMouseY = e.clientY - rect.top;
                
                let hovering = false;
                for (const bubble of souvenirsBubbles) {
                    const dx = souvenirsMouseX - bubble.x;
                    const dy = souvenirsMouseY - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < bubble.size / 2) {
                        hovering = true;
                        break;
                    }
                }
                canvas.style.cursor = hovering ? 'pointer' : 'default';
            };
            
            const handleClick = async (e) => {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                for (const bubble of souvenirsBubbles) {
                    const dx = clickX - bubble.x;
                    const dy = clickY - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bubble.size / 2) {
                        // Load souvenir dynamically instead of full page reload
                        await loadAndRenderSouvenir(bubble.key);
                        
                        // Update phanera background to the new souvenir
                        if (currentSouvenir && currentSouvenir.phanera) {
                            const newImage = new Image();
                            newImage.src = currentSouvenir.phanera;
                            newImage.onload = () => {
                                // Crossfade to new phanera
                                const fadeOut = setInterval(() => {
                                    phaneraBgAlpha = Math.max(0, phaneraBgAlpha - 0.05);
                                    if (phaneraBgAlpha <= 0) {
                                        clearInterval(fadeOut);
                                        phaneraBgImage = newImage;
                                        const fadeIn = setInterval(() => {
                                            phaneraBgAlpha = Math.min(1, phaneraBgAlpha + 0.05);
                                            if (phaneraBgAlpha >= 1) clearInterval(fadeIn);
                                        }, 16);
                                    }
                                }, 16);
                            };
                        }
                        return;
                    }
                }
            };
            
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleClick);
            
            // Load the current souvenir's phanera as background
            if (currentSouvenir && currentSouvenir.phanera) {
                phaneraBgImage = new Image();
                phaneraBgImage.src = currentSouvenir.phanera;
                phaneraBgImage.onload = () => {
                    phaneraBgAlpha = 1;
                };
            }
            
            // Load and create bubbles
            try {
                const response = await fetch('/api/souvenirs');
                const rawSouvenirs = await response.json();
                
                souvenirsBubbles = [];
                
                // Create bubble for each souvenir
                const souvenirKeys = Object.keys(rawSouvenirs);
                const widgetWidth = 280;
                const widgetHeight = 150;
                const widgetMargin = 12;
                
                if (souvenirKeys.length === 0) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#fdfcfe';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#999';
                    ctx.font = 'italic 14px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Explore all the souvenirs available to collect.', canvas.width / 2, canvas.height / 2 - 20);
                    return;
                }
                
                souvenirKeys.forEach((key) => {
                    const souvenir = rawSouvenirs[key];
                    const minSize = 55;
                    const maxSize = 85;
                    const size = minSize + Math.random() * (maxSize - minSize);
                    
                    let x, y, attempts = 0;
                    do {
                        x = size / 2 + Math.random() * (canvas.width - size);
                        y = size / 2 + Math.random() * (canvas.height - size);
                        
                        const widgetLeft = widgetMargin;
                        const widgetRight = widgetMargin + widgetWidth;
                        const widgetTop = canvas.height - widgetMargin - widgetHeight;
                        const widgetBottom = canvas.height - widgetMargin;
                        
                        const padding = size / 2 + 20;
                        const isOutsideWidget = x > widgetRight + padding || 
                                               x < widgetLeft - padding ||
                                               y < widgetTop - padding ||
                                               y > widgetBottom + padding;
                        
                        if (isOutsideWidget) break;
                        attempts++;
                    } while (attempts < 50);
                    
                    if (attempts >= 50) {
                        x = canvas.width * 0.6 + Math.random() * (canvas.width * 0.3);
                        y = canvas.height * 0.2 + Math.random() * (canvas.height * 0.3);
                    }
                    
                    const minVelocity = 1.5;
                    const maxVelocity = 4;
                    let vx = (Math.random() - 0.5) * maxVelocity * 2;
                    let vy = (Math.random() - 0.5) * maxVelocity * 2;
                    
                    const speed = Math.sqrt(vx * vx + vy * vy);
                    if (speed < minVelocity) {
                        const angle = Math.random() * Math.PI * 2;
                        vx = Math.cos(angle) * minVelocity;
                        vy = Math.sin(angle) * minVelocity;
                    } else if (speed > maxVelocity) {
                        vx = (vx / speed) * maxVelocity;
                        vy = (vy / speed) * maxVelocity;
                    }
                    
                    const bubble = {
                        key: key,
                        name: souvenir.name,
                        icon: souvenir.icon,
                        phanera: souvenir.phanera,
                        x: x,
                        y: y,
                        vx: vx,
                        vy: vy,
                        size: size,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        image: new Image()
                    };
                    
                    bubble.image.src = bubble.icon;
                    souvenirsBubbles.push(bubble);
                });
                
                startSouvenirsAnimation(canvas);
                
            } catch (error) {
                console.error('[Souvenirs] Error loading souvenirs:', error);
            }
        }
        
        function startSouvenirsAnimation(canvas) {
            const ctx = canvas.getContext('2d');
            let animationTime = 0;
            const userColor = window.ColorManager?.currentColor || '#734ba1';
            
            const animate = () => {
                animationTime += 0.01;
                
                const r = parseInt(userColor.slice(1, 3), 16);
                const g = parseInt(userColor.slice(3, 5), 16);
                const b = parseInt(userColor.slice(5, 7), 16);
                const oscillation = Math.sin(animationTime) * 0.5 + 0.5;
                
                const gradient1 = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient1.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.03 + oscillation * 0.02})`);
                gradient1.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${0.08 - oscillation * 0.02})`);
                
                ctx.fillStyle = '#fdfcfe';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw phanera background
                if (phaneraBgImage && phaneraBgImage.complete && phaneraBgImage.naturalWidth > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.2 * phaneraBgAlpha;
                    
                    const imgAspect = phaneraBgImage.naturalWidth / phaneraBgImage.naturalHeight;
                    const canvasAspect = canvas.width / canvas.height;
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgAspect > canvasAspect) {
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    }
                    
                    ctx.drawImage(phaneraBgImage, drawX, drawY, drawWidth, drawHeight);
                    ctx.restore();
                }
                
                ctx.fillStyle = gradient1;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw bubbles
                souvenirsBubbles.forEach((bubble, i) => {
                    bubble.x += bubble.vx;
                    bubble.y += bubble.vy;
                    bubble.rotation += bubble.rotationSpeed;
                    
                    const minVelocity = 0.8;
                    const maxVelocity = 5;
                    const speed = Math.sqrt(bubble.vx * bubble.vx + bubble.vy * bubble.vy);
                    
                    if (speed > maxVelocity) {
                        bubble.vx = (bubble.vx / speed) * maxVelocity;
                        bubble.vy = (bubble.vy / speed) * maxVelocity;
                    } else if (speed < minVelocity && speed > 0) {
                        bubble.vx = (bubble.vx / speed) * minVelocity;
                        bubble.vy = (bubble.vy / speed) * minVelocity;
                    }
                    
                    const dx = souvenirsMouseX - bubble.x;
                    const dy = souvenirsMouseY - bubble.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const isHovered = distance < bubble.size / 2;
                    
                    // Wall collisions
                    if (bubble.x - bubble.size / 2 < 0) {
                        bubble.x = bubble.size / 2;
                        bubble.vx = Math.abs(bubble.vx);
                    }
                    if (bubble.x + bubble.size / 2 > canvas.width) {
                        bubble.x = canvas.width - bubble.size / 2;
                        bubble.vx = -Math.abs(bubble.vx);
                    }
                    if (bubble.y - bubble.size / 2 < 0) {
                        bubble.y = bubble.size / 2;
                        bubble.vy = Math.abs(bubble.vy);
                    }
                    if (bubble.y + bubble.size / 2 > canvas.height) {
                        bubble.y = canvas.height - bubble.size / 2;
                        bubble.vy = -Math.abs(bubble.vy);
                    }
                    
                    // Widget collision
                    const widget = document.querySelector('.souvenirs-mini-widget');
                    if (widget && widget.innerHTML) {
                        const rect = widget.getBoundingClientRect();
                        const canvasRect = canvas.getBoundingClientRect();
                        
                        const widgetLeft = rect.left - canvasRect.left;
                        const widgetTop = rect.top - canvasRect.top;
                        const widgetRight = widgetLeft + rect.width;
                        const widgetBottom = widgetTop + rect.height;
                        
                        const bubbleRadius = bubble.size / 2;
                        const closestX = Math.max(widgetLeft, Math.min(bubble.x, widgetRight));
                        const closestY = Math.max(widgetTop, Math.min(bubble.y, widgetBottom));
                        
                        const distX = bubble.x - closestX;
                        const distY = bubble.y - closestY;
                        const dist = Math.sqrt(distX * distX + distY * distY);
                        
                        if (dist < bubbleRadius && dist > 0) {
                            const pushX = (distX / dist) * (bubbleRadius - dist);
                            const pushY = (distY / dist) * (bubbleRadius - dist);
                            bubble.x += pushX;
                            bubble.y += pushY;
                            
                            const normalX = distX / dist;
                            const normalY = distY / dist;
                            const dotProduct = bubble.vx * normalX + bubble.vy * normalY;
                            bubble.vx -= 2 * dotProduct * normalX;
                            bubble.vy -= 2 * dotProduct * normalY;
                            bubble.vx *= 0.9;
                            bubble.vy *= 0.9;
                        }
                    }
                    
                    // Bubble-to-bubble collisions
                    for (let j = i + 1; j < souvenirsBubbles.length; j++) {
                        const other = souvenirsBubbles[j];
                        const dx = other.x - bubble.x;
                        const dy = other.y - bubble.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDist = (bubble.size + other.size) / 2;
                        
                        if (distance < minDist && distance > 0) {
                            const angle = Math.atan2(dy, dx);
                            const targetX = bubble.x + Math.cos(angle) * minDist;
                            const targetY = bubble.y + Math.sin(angle) * minDist;
                            
                            const ax = (targetX - other.x) * 0.5;
                            const ay = (targetY - other.y) * 0.5;
                            bubble.x -= ax;
                            bubble.y -= ay;
                            other.x += ax;
                            other.y += ay;
                            
                            const vxTemp = bubble.vx;
                            const vyTemp = bubble.vy;
                            bubble.vx = other.vx * 0.95;
                            bubble.vy = other.vy * 0.95;
                            other.vx = vxTemp * 0.95;
                            other.vy = vyTemp * 0.95;
                        }
                    }
                    
                    // Draw bubble
                    ctx.save();
                    
                    if (isHovered) {
                        ctx.translate(bubble.x, bubble.y);
                        ctx.scale(1.1, 1.1);
                        ctx.translate(-bubble.x, -bubble.y);
                    }
                    
                    const gradient = ctx.createRadialGradient(
                        bubble.x - bubble.size * 0.2, 
                        bubble.y - bubble.size * 0.2, 
                        0,
                        bubble.x, 
                        bubble.y, 
                        bubble.size / 2
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(200, 220, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(180, 200, 255, 0.2)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(bubble.x, bubble.y, bubble.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = isHovered ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = isHovered ? 3 : 2;
                    ctx.stroke();
                    
                    if (bubble.image.complete && bubble.image.naturalWidth > 0) {
                        const iconSize = bubble.size * 0.85;
                        ctx.globalAlpha = 0.95;
                        
                        ctx.save();
                        ctx.translate(bubble.x, bubble.y);
                        ctx.rotate(bubble.rotation);
                        
                        ctx.drawImage(
                            bubble.image,
                            -iconSize / 2,
                            -iconSize / 2,
                            iconSize,
                            iconSize
                        );
                        
                        ctx.restore();
                        ctx.globalAlpha = 1;
                    }
                    
                    ctx.restore();
                });
                
                souvenirsAnimationFrame = requestAnimationFrame(animate);
            };
            
            animate();
        }
        
        // Function to load and render a specific souvenir
        async function loadAndRenderSouvenir(key) {
            console.log('ðŸŽ [Souvenirs] Loading souvenir for key:', key);
            
            souvenirKey = key;
            currentSouvenir = allSouvenirs[souvenirKey];
            
            if (!currentSouvenir) {
                console.error('âŒ [Souvenirs] Souvenir not found:', souvenirKey);
                return;
            }
            
            // Get the souvenir frame for animation
            const souvenirFrame = document.getElementById('souvenir-frame');
            const souvenirIcon = document.getElementById('souvenir-icon');
            const souvenirInfo = document.querySelector('.souvenir-info-section');
            
            // Fade out current content
            if (souvenirFrame) {
                souvenirFrame.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                souvenirFrame.style.opacity = '0';
                souvenirFrame.style.transform = 'scale(0.98) translateY(-5px)';
            }
            
            // Wait for fade out
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Update URL
            updateURL(souvenirKey);
            
            // Update background
            if (window.background && currentSouvenir.phanera) {
                const phaneraUrl = currentSouvenir.phanera || 'souvenirs/residence/phanera.png';
                // Use the full path for phanera
                const fullPhaneraUrl = phaneraUrl.startsWith('/') ? phaneraUrl : `/souvenirs/${souvenirKey}/phanera.png`;
                window.background.showPhaneraBackgroundUrl(fullPhaneraUrl);
            }
            
            // Render souvenir content
            renderSouvenirPage();
            
            // Fade in new content
            await new Promise(resolve => setTimeout(resolve, 50));
            if (souvenirFrame) {
                souvenirFrame.style.opacity = '1';
                souvenirFrame.style.transform = 'scale(1) translateY(0)';
            }
            
            // Add a little bounce to the icon
            if (souvenirIcon) {
                souvenirIcon.style.animation = 'none';
                setTimeout(() => {
                    souvenirIcon.style.animation = 'souvenir-pop 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                }, 100);
            }
            
            // Restore the last selected tab
            const lastSelectedFace = localStorage.getItem('souvenir-selected-face') || 'events';
            switchToFace(lastSelectedFace);
        }
        
        // Load souvenir data
        async function loadSouvenirData() {
            console.log('ðŸŽ [Souvenirs] Loading souvenir data for key:', souvenirKey);
            try {
                const response = await fetch('/api/souvenirs');
                allSouvenirs = await response.json();
                
                if (allSouvenirs[souvenirKey]) {
                    currentSouvenir = allSouvenirs[souvenirKey];
                    renderSouvenirPage();
                } else {
                    console.error('âŒ [Souvenirs] Souvenir not found:', souvenirKey);
                }
            } catch (error) {
                console.error('âŒ [Souvenirs] Error loading souvenirs:', error);
            }
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.souvenirKey) {
                loadAndRenderSouvenir(event.state.souvenirKey);
            }
        });
        
        async function renderSouvenirPage() {
            if (!currentSouvenir) return;
            
            // Background is now handled by the Background widget in souvenirs.js
            // No need to set it here
            
            // Set user color for the souvenir
            const souvenirColor = window.ColorManager?.currentColor || '#734ba1';
            document.documentElement.style.setProperty('--user-color', souvenirColor);
            
            // Render souvenir icon
            const iconBubble = document.getElementById('souvenir-icon');
            iconBubble.innerHTML = `<img src="${currentSouvenir.icon || '/assets/icon_face.png'}" alt="${currentSouvenir.name}" class="souvenir-icon">`;
            
            // Render text content
            document.getElementById('souvenir-title').textContent = currentSouvenir.name;
            document.getElementById('souvenir-description').textContent = currentSouvenir.description || '';
            
            // Render keeper count
            const keeperCount = currentSouvenir.keepers?.length || 0;
            document.getElementById('souvenir-details').textContent = getKeeperText(keeperCount, currentSouvenir.keepers);
            
            // Render event stack (Events face) - fetch ALL events with this key
            fetchEventsForKey(currentSouvenir.key).then(events => {
                const eventStack = new EventStack();
                eventStack.render(events, document.getElementById('souvenir-events-face'), {
                    colorMode: 'auto'
                });
            });
            
            // Render keepers list (Keepers face)
            renderKeepersList(currentSouvenir.keepers || []);
            
        }
        
        async function fetchEventsForKey(souvenirKey) {
            try {
                const response = await fetch('/api/canon');
                const allEvents = await response.json();
                
                // Filter events that have matching key (including dream events)
                const matchingEvents = allEvents.filter(event => event.key === souvenirKey);
                
                console.log(`[Souvenirs] Found ${matchingEvents.length} events with key: ${souvenirKey}`);
                return matchingEvents;
            } catch (error) {
                console.error('[Souvenirs] Error fetching events:', error);
                return [];
            }
        }
        
        async function renderKeepersList(keepers) {
            const keepersList = document.getElementById('keepers-list');
            if (!keepersList) return;
            
            if (keepers.length === 0) {
                keepersList.innerHTML = '<div style="text-align: center; color: #999; padding: 40px; font-style: italic;">No keepers yet</div>';
                return;
            }
            
            // Fetch dreamer data for each keeper
            try {
                const response = await fetch('/api/dreamers');
                const dreamers = await response.json();
                
                const keeperItems = keepers.map(keeper => {
                    const dreamer = dreamers.find(d => d.did === keeper.did);
                    if (!dreamer) return '';
                    
                    const avatarUrl = dreamer.avatar || '/assets/icon_face.png';
                    const octant = dreamer.spectrum?.octant || 'unknown';
                    const octantClass = octant !== 'unknown' ? `octant-${octant}` : '';
                    const userColor = dreamer.color_hex || '#734ba1';
                    
                    // Get spectrum scores
                    const intentional = dreamer.spectrum?.intentional || 0;
                    const expressive = dreamer.spectrum?.expressive || 0;
                    const skeptic = dreamer.spectrum?.skeptic || 0;
                    const receptive = dreamer.spectrum?.receptive || 0;
                    const creative = dreamer.spectrum?.creative || 0;
                    const reactive = dreamer.spectrum?.reactive || 0;
                    
                    const total = Math.abs(intentional) + Math.abs(expressive) + Math.abs(skeptic) + 
                                  Math.abs(receptive) + Math.abs(creative) + Math.abs(reactive);
                    
                    const oblivionWidth = total > 0 ? (Math.abs(intentional) / total * 100) : 0;
                    const authorityWidth = total > 0 ? (Math.abs(expressive) / total * 100) : 0;
                    const skepticWidth = total > 0 ? (Math.abs(skeptic) / total * 100) : 0;
                    const receptiveWidth = total > 0 ? (Math.abs(receptive) / total * 100) : 0;
                    const libertyWidth = total > 0 ? (Math.abs(creative) / total * 100) : 0;
                    const entropyWidth = total > 0 ? (Math.abs(reactive) / total * 100) : 0;
                    
                    // Determine status
                    let status = 'Dreamer';
                    if (dreamer.known_dreamer) {
                        status = 'Known';
                    }
                    if (dreamer.status === 'resident') {
                        status = 'Resident';
                    }
                    
                    const earnedTime = timeAgo(keeper.epoch);
                    
                    return `
                        <div class="keeper-card ${octantClass}" style="--user-color: ${userColor};\" onclick="window.location.href='/dreamer?did=${encodeURIComponent(dreamer.did)}'">
                            <img src="${avatarUrl}" alt="${dreamer.name}" class="keeper-card-avatar" onerror="this.src='/assets/icon_face.png'">
                            <div class="keeper-card-info">
                                <div class="keeper-card-name">${dreamer.name}</div>
                                <div class="keeper-card-handle">@${dreamer.handle}</div>
                                ${octant !== 'unknown' ? `<div class="keeper-badge-octant octant-bg-${octant}">${octant.toUpperCase()}</div>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                keepersList.innerHTML = keeperItems;
            } catch (error) {
                console.error('[Souvenirs] Error loading keepers:', error);
                keepersList.innerHTML = '<div style="text-align: center; color: #d9534f; padding: 40px;">Failed to load keepers</div>';
            }
        }
        
        function getKeeperText(count, keepers) {
            if (count === 0) return "no keepers";
            
            // Use NumNom utility for number to word conversion
            const numberToWord = window.NumNom?.numberToWord || ((n) => n.toString());
            
            const nominativeCall = (num) => {
                if (num === 0) return "zero keepers";
                if (num === 1) return "one keeper";
                return `${numberToWord(num)} keepers`;
            };
            
            // Get earliest keeper timestamp
            if (keepers && keepers.length > 0) {
                const earliestEpoch = Math.min(...keepers.map(k => k.epoch));
                const timeText = timeAgo(earliestEpoch);
                const nomCall = nominativeCall(count);
                return `${nomCall} of ${timeText}`;
            }
            
            return nominativeCall(count);
        }
        
        function timeAgo(timestamp) {
            const now = Date.now() / 1000;
            const diff = now - timestamp;
            const days = Math.floor(diff / (24 * 60 * 60));
            
            if (days <= 45) return "about a month";
            if (days <= 60) return "two months";
            if (days <= 90) return "some months";
            
            const months = Math.floor(days / 30);
            if (months < 12) return `${months} months`;
            
            const years = Math.floor(days / 365);
            return years === 1 ? "about a year" : `about ${years} years`;
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            console.log('ðŸŽ [Souvenirs] Page fully loaded...');
        });
        
        // Initialize souvenir data on DOM ready
        window.addEventListener('DOMContentLoaded', () => {
            console.log('ðŸŽ [Souvenirs] DOM ready, starting load...');
            
            loadSouvenirData();
            
            // Setup toggle button
            const toggleBtn = document.getElementById('toggle-details-btn');
            const souvenirFrame = document.getElementById('souvenir-frame');
            let isVisible = true;
            
            toggleBtn.addEventListener('click', () => {
                isVisible = !isVisible;
                
                if (isVisible) {
                    souvenirFrame.classList.remove('hidden');
                    toggleBtn.classList.remove('details-hidden');
                } else {
                    souvenirFrame.classList.add('hidden');
                    toggleBtn.classList.add('details-hidden');
                }
            });
            
            // Setup tab switching
            const tabButtons = document.querySelectorAll('.souvenir-face-btn');
            const eventsFace = document.getElementById('souvenir-events-face');
            const keepersFace = document.getElementById('souvenir-keepers-face');
            const bouncerFace = document.getElementById('souvenir-bouncer-face');
            
            // Restore last selected tab from localStorage
            const lastSelectedFace = localStorage.getItem('souvenir-selected-face') || 'events';
            console.log('ðŸŽ [Souvenirs] Restoring tab:', lastSelectedFace);
            
            // Restore the last selected face on load
            switchToFace(lastSelectedFace);
            
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const face = btn.dataset.face;
                    switchToFace(face);
                });
            });
        });
    </script>
</body>
</html>
